
# Daily

A place where I write public daily thoughts.


<h2 id="09-25-2022" ><a href="#09-25-2022">25th September, 2022</a></h2>

A few months ago I integrated Amplify into a [Remix.run](https://remix.run/) app and today I [saw an example that took a different approach by using AppSync with ApolloGraphQL](https://github.com/aaronksaunders/amplify-remix-todos-1).

I felt that approach was a bit overkill. The only trick to get [Amplify's `withSSRContext`](https://docs.amplify.aws/lib/ssr/q/platform/js/) working is to properly map Remix's request object to the one `withSSRContext` expects, which I do as follow:


```javascript
const client = withSSRContext({
  req: { headers: { cookie: args.request.headers.get("cookie") } },
});
```

The above code would be in a Remix loader function.

<h2 id="09-24-2022" ><a href="#09-24-2022">24th September, 2022</a></h2>

Today I spent some time trying to figure out why Amplify was stuck on this `Resource is not in the state stackUpdateComplete` error.

**Error:**

```cli
‚úñ An error occurred when pushing the resources to the cloud
üõë An error occurred during the push operation: /
["Index: 0 State: {\"deploy\":\"waitingForDeployment\"} Message: Resource is not in the state stackUpdateComplete"]
‚ö†Ô∏è Review the Amplify CLI troubleshooting guide for potential next steps: https://docs.amplify.aws/cli/project/troubleshooting/
````

At first, without much AWS experience this kind of error is quite bizarre. Well, after a lots of digging you start to learn the following:

1) Amplify automates creation of resources  
2) This automation is done by CloudFormation's stacks  
3) The "resource is not in the state stackUpdateComplete" refers to a stack resource in CloudFormation.  

After understanding the following I finally started looking in the right place. CloudFormation's stack display exactly which stack had an error. In my case, it was some DynamoDB table that was stuck.

A common issue with CloudFormation is configuration drift - this is when your automated configs are different from the actual resources because someone changed something through the UI instead of your config code (in my case these configs are managed by Amplify).

The drift issue is so common [they have an entire section/UI dedicated to identifying such issues](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/detect-drift-stack.html).

Once I got to the drift problem I was able to rapidly identified one of the resources that drifted. But how do I revert this issue?

You can resolve the drift by either:

1) Manually reverting the change you did via UI   
2) Updating the CloudFormation's stack template (I did this via its change set feature).  

I chose the second option since I couldn't find the UI option that triggered the initial change.

Another tip is to look for the actual failing resource within the stacks, you are likely to find a log there that can help. For my case we were having the [GSI error issue described here](https://stackoverflow.com/questions/62976032/how-can-i-update-dynamodb-gsi-when-projection-type-is-changed).

<h2 id="09-23-2022" ><a href="#09-23-2022">23rd September, 2022</a></h2>

In big tech companies, nothing will get built if it moves no key result (OKR). Today I heard someone say I'm not sure we want to prioritize a given task simply because there is no KR tracking given result.

---------------

**A better useEffect** for when you need to react to a state change.

```typescript
import { useRef } from 'react';

const useOnUpdated = (cb: () => void, dependency: any) => {
  const last = useRef<any>(undefined);

  if (dependency !== last.current) {
    last.current = dependency;
    cb();
  }
};

```

But why? 

Well, useEffect is often called more times than you expect. This hooks adds simplicity and predictability over behavior. Plus, the single dependency is intentional to make sure we are only doing one thing instead of many things - you would prefer multiple useOnUpdated which will result in easier to maitain code.


<h2 id="09-22-2022" ><a href="#09-22-2022">22nd September, 2022</a></h2>

There are days we spin our wheels and accomplish almost nothing. 

Today was a day I had to remind myself how to find specific files and search for certain patterns. Over time I am more and more convinced that it is better to learn the lower level commands on the CLI than to rely on any IDE feature for common search and edit file or file contents.

How do you find an apk file within your directory? 

`find . -type file -name "*.apk"`


How do you find a file that imports a module named "config" which is imported from "mobule-b"? 

Turns out "config" is quite a common word and "mobule-b" might be imported 100s of times. 

The following can do that for you:  
`rg -U 'import.*config.*mobule-b'`

The trick here is enabling multiline grep with the `-U` option.


<h2 id="09-21-2022" ><a href="#09-21-2022">21th September, 2022</a></h2>

Today was a long day. I had a nice opportunity to improve React Native's horizontal scroll view. I found an edge case where the snap to animation was very slow/sluggish. [See PR here](https://github.com/facebook/react-native/pull/34756).

This was part of yesterday's work and why I had to run my app by compiling react-native's source.

I wrote a [TIL about git diff's file filtering feature](/posts/2022-09-21/til-git-diff-file-filter).

<h2 id="09-20-2022" ><a href="#09-20-2022">20th September, 2022</a></h2>

Today I had to patch react-native's source code to fix an Android issue.

Turns out by default react-native only compiles its native code when the new Fabric architecture is enabled else it uses a prebuilt lib.

To turn on compilation of react-native's source code you need to remove the following if checks in [build.gradle](https://github.com/facebook/react-native/blob/bcb58089c4723a005326cb7a8b44e349c6a9a451/template/android/app/build.gradle) and [settings.gradle](https://github.com/facebook/react-native/blob/bcb58089c4723a005326cb7a8b44e349c6a9a451/template/android/settings.gradle):

```gradle
M src/packages/app/android/app/build.gradle
@@ -423,7 +423,7 @@ dependencies {
     implementation 'com.google.android.play:core:1.8.0'
 }
 
-if (isNewArchitectureEnabled()) {
+// if (isNewArchitectureEnabled()) {
     // If new architecture is enabled, we let you build RN from source
     // Otherwise we fallback to a prebuilt .aar bundled in the NPM package.
     // This will be applied to all the imported transtitive dependency.
@@ -437,7 +437,7 @@ if (isNewArchitectureEnabled()) {
             //         .because("On New Architecture we're building Hermes from source")
         }
     }
-}
+// }
 
 apply from: file("$nodeModulesPath/@react-native-community/cli-platform-android/native_modules.gradle"); applyNativeModulesAppBuildGradle(project)
```


```gradle
M src/packages/app/android/settings.gradle
@@ -7,11 +7,12 @@ apply from: file("$nodeModulesPath/@react-native-community/cli-platform-android/
 include ':app'
 includeBuild("$nodeModulesPath/react-native-gradle-plugin")
 
+include(":ReactAndroid")
+project(":ReactAndroid").projectDir = file("$nodeModulesPath/react-native/ReactAndroid")
+
 if (settings.hasProperty("newArchEnabled") && settings.newArchEnabled == "true") {
-    include(":ReactAndroid")
-    project(":ReactAndroid").projectDir = file("$nodeModulesPath/react-native/ReactAndroid")
-    include(":ReactAndroid:hermes-engine")
-    project(":ReactAndroid:hermes-engine").projectDir = file("$nodeModulesPath/react-native/ReactAndroid/hermes-engine")
+	include(":ReactAndroid:hermes-engine")
+	project(":ReactAndroid:hermes-engine").projectDir = file("$nodeModulesPath/react-native/ReactAndroid/hermes-engine")
 }
```


Once I compiled its source code I could debug it with Android Studio and find where to fix the issue. I'll post about the issue on another day.


<h2 id="09-19-2022" ><a href="#09-19-2022">19th September, 2022</a></h2>

Hello world. It was on my TODO list that I was going to get this done. So, I'm done = ).

But, here are some random thoughts:


**1) There are no reliable dev environments in the finance industry**

I've been working in the Crypto space for a year now and this is a huge pain point for us. Researching about the topic I learned it is a shared pain due to the number of external integrations with legacy bank systems. Plus, it is hard to maintain fakers for every API you have. 

**2) Handling app errors gracefully**

This has been a recorrent topic at work. The app grew and an initial pattern implemented in the early days of the app is becoming bad user experience - full screen errors. 

Over the years I noticed a few patterns emerge while building apps. The first is fully neglecting errors and letting apps just crash. The second pattern is typically a solution for the first which is a generic error screen that serves as a catch all, this is the stage where the current app I work with is at. And perhaps the last stage is pushing error handling closer to the leaf UI elements that cause them in the UI tree with addition to proper reaction mechanisms such as retries.


In hingsight it feels like if we instead started backwards - that is handling errors only at the leaf nodes before going higher up the UI tree, this could make it easier over time to deliver a better UX.

But why doesn't that happen? 

I don't know the answer. But, I would think that the clear lack of paved road in this area makes for less experienced developers to simply neglect error handling as a whole.




